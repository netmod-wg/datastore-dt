
* Advice to Modelers

The "Network Management Datastore Architecture" (NMDA)
^I-D.netmod-revised-datastore^ adds the ability to inspect the current
operational values for configuration, allowing clients to use
identical paths for retrieving the configured values and the
operational values.  This change will simplify models and help
modelers, but will create a period of churn as NMDA becomes a standard
and is widely implemented.  During that interim, the guidelines given
in this section should help modelers find an optimal path forward.

** Background

NETCONF (^RFC6241^) was developed with a focus on configuration data,
and has unfortunate gaps in its treatment of operational data.  The
<get-config> operation can return configuration data (defined as nodes
with "config true") stored in the <running> datastore.  This data is
typically only the data created by CLI users and NETCONF clients.  The
<get> operation is defined as returning all the data on the device,
including the contents of the <running> datastore, as well as any
operational data.  While the NETCONF designers intended to merge
"config false" nodes with the contents of running, there are two
issues involved.

First, the desire of clients to see the true operational "in use" value
of configuration data means that two distinct leafs were required to
show both the configured value and the operational value.  An example
would be the speed of an interface, where the configured value may not
be the value that is currently used.

Second, devices often have "system created" resources that exist as
operational data even when there is no corresponding configuration
data.  An example would be built-in networking interfaces that always
appear in operational data.

A similar situation exists while the device is processing configuration
data changes.  When configuration data is deleted, the operational
data will continue to exist during the time period in which the device
is releasing resources associated with the data.  An example would be
deleting a BGP peer, where the peer continues to exist in operational
data until the connection is closed and any other resources are
released.

To address these issues with NETCONF, two distinct strategies have
been adopted:

The first strategy makes two distinct top-level containers, one for
configuration and one for state.  These are sometimes referred to as
"/foo" and "/foo-state".  An example would be the interface model
defined in ^RFC7223^.  These models require two completely distinct
set of nodes, with repetition of both the interior containers, lists,
and key nodes, but also repetition of many other nodes to allow
visibility of the operational values of configured nodes.  This leads
to over-use of YANG groupings in ways that affect the readability of
the models, as well as creating opportunities to incorrectly mirror
the model's hierarchies.  Also this "stitching together" of data from
the two trees is completely a convention, not a formal relationship.

The second strategy uses two sibling containers, named "config" and
"state", placed deeper within the hierarchy.  The "config" container
holds the configured values, while the "state" container holds the
operational values.  The duplication of interior nodes in the
hierarchies is removed, but the duplication of leafs representing
configuration remains.  Groupings can be used to avoid the repetition
of the leafs in the YANG file, but at the expense of readability.  In
addition, this strategy does not handle the existence of operational
data for which there is no configuration data, such as the
system-created data and deleted peers scenarios discussed above.

** Network Management Datastores Architecture

The Network Management Datastores Architecture (NMDA) addresses these
problems with NETCONF by creating a distinct datastore for operational
data, called <operational>.  When retrieving data from <operational>,
all currently "in use" values are returned.  This allows modelers to
use a single hierarchy for both configuration and operational data,
without concerns about missing vital operational data.

In addition, another datastore named <intended> is defined that gives
a complete view of the configuration data, even in the presence of
device-specific features that expand or remove configuration data.
While such mechanisms are currently non-standard, the NMDA recognizes
they exist and need to be handled appropriately.  In the future, such
mechanisms may become standardized.

The NMDA also deprecates NETCONF's <get> operation, removing the
source of these issues.  Similar changes are planned for RESTCONF
(^RFC8040^).

** Guidelines for Modelers

The following guidelines are meant to help modelers develop models
that will maximize the utility of the model with both current
implementations and NMDA-capable implementations.

The direction taken should be based on both the maturity of the data
model, along with the number of concrete implementations of the model.
The intent is not to destabilize the IETF modeling community, but to
create models that can take advantage of the NMDA.

When evaluating the impact to a particular data model, the following
guidelines should be considered:

(a) For new models or models with a sufficiently long development time
line, the model should target the NMDA, with the expectation that their
models will be used by NMDA-capable implementations and their
operational data will be available via the <operational> datastore.

(b) For models under development that have no serious dependency on
operational data, the model should target the NMDA, since the
impact would be minimal.  When NMDA-capable implementations arrived,
the operational data will be available in the <operational> datastore.

(c) For models under development that need visibility into their
operational values and are not able to delay for the NMDA-capable
implementations, a "state" container should be created that will
contain "config false" nodes corresponding to any "config true" nodes
for which operational values are needed.  Any other "config false"
nodes can be placed as siblings to the "config true" nodes.  In the
future, these "state" containers SHOULD be marked as deprecated, since
the <operational> datastore will then provide those values.

(d) For models under development that currently use distinct "config"
and "state" containers to segregate operational values, the modeler
has a difficult decision, since the current structure is not
well-aligned to the future.  Whenever possible, the model should be
restructured in an NMDA-compatible manner, by deprecating the "state"
containers and moving the contents of the "config" containers to their
parent nodes.  But where the maturity of the model and the active
development work makes that problematic, the impact for NMDA-capable
implementations will be duplication of operational state under both
"config" and "state" in the <operational> datastore.  This will lead
to confusion when a <get-data> operation from the <operational>
datastore returns a "config" container that contains operational
state, not configuration values.

(e) For models under development that are using the top-level state
container (aka "/foo-state"), the modeler has a difficult decision,
since the current structure is not well-aligned to the future.
Whenever possible, the model should be restructured in an
NMDA-compatible manner, moving nodes from the "/foo-state" to an
appropriate location within the "/foo" hierarchy.
- For state nodes which have no corresponding "config true" node,
move the nodes to the corresponding node within the primary tree.
- For state nodes which have a corresponding "config true" node,
move the nodes under a "state" container that is peer to the "config
true" node.

(f) There are models for which the NMDA structure makes little sense,
e.g. because the operational data is organized in a completely
different structure than the configuration data.  [Need example.]  For
such models, retaining a distinct "/foo-state" hierarchy may continue
to make sense.

(g) For models that augment other models, the modeler will have to
consider the structure of the base model and the guidelines listed
above.  In general, augmenting "state" containers should be avoided,
with the expectation that the base model will be re-released with any
state containers marked as deprecated.

It is critical to consider these as guidelines, understanding that our
goal is to make models that will see continued use in the long term.
There needs to be a balance between short term needs and a desire
for consistent, usable models in the future.

For models using guideline (e), one additional guideline should be
considered.  Publishing a model for a distinct "/foo-state" tree means
that even implementations that are NMDA-capable will be forced to
duplicate operational state under that hierarchy.  Modelers might
consider marking their "/foo-state" hierarchy as "status deprecated"
to allow NMDA-capable implementations to avoid the cost of duplicating
those nodes.  Non-NMDA-capable implementations would implement them as
a means of allowing access to these operational values.  This decision
would need to take into account the progress of the NMDA and the
availability of NMDA-capable implementations.
