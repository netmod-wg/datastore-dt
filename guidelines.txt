
* Advice to Modelers

The "Revised Datastore Architecture" (RDA) ^I-D.netmod-revised-datastore^
adds the ability to inspect the current operational values for
configuration, allowing clients to use identical paths for retrieving
the configured values and the operational values.  This change will
simplify models and help modelers, but will create a period of churn
as RDA becomes a standard and is widely implemented.  During that
interim, the guidelines given in this section should help modelers
find an optimal path forward.

** Background

NETCONF (^RFCXXXX^) was developed with a focus on configuration data,
and has unfortunate gaps in its treatment of operational data.  The
<get-config> operation can return configuration data (defined as nodes
with "config true") stored in the <running> datastore.  This data is
typically only the data created by CLI users and NETCONF clients.  The
<get> operation is defined as returning all the data on the device,
including the contents of the <running> datastore, as well as any
operational data.  While the NETCONF designers intended to merge
"config false" nodes with the contents of running, there are two
issues involved.

First, the desire of clients to see the true operational "in use" value
of configuration data means that two distinct leafs were required to
show both the configured value and the operational value.  An example
would be the speed of an interface, where the configured value may not
be the value that is currently used.

Second, devices often have "system created" resources that exist as
operational data even when there is no corresponding configuration
data.  An example would be built-in networking interfaces that always
appear in operational data.

A similar situation exists while the device is processing configuration
data changes.  When configuration data is deleted, the operational
data will continue to exist during the time period in which the device
is releasing resources associated with the data.  An example would be
deleting a BGP peer, where the peer continues to exist in operational
data until the connection is closed and any other resources are
released.

To address these issues with NETCONF, two distinct strategies have
been adopted.  The first strategy makes two distinct top-level
containers, one for configuration and one for state.  These are
sometimes referred to as "/foo" and "/foo-state".  An example would be
the interface model defined in ^RFCXXXX^.

These models require two completely distinct set of nodes, with
repetition of both the interior containers, lists, and key nodes, but
also repetition of many other nodes to allow visibility of the
operational values of configured nodes.  This leads to over-use of
YANG groupings in ways that affect the readability of the models, as
well as creating opportunities to incorrectly mirror the model's
hierarchies.  Also this "stitching together" of data from the two
trees is completely a convention, not a formal relationship.

The second strategy uses two sibling containers, named "config" and
"state", placed deeper within the hierarchy.  The "config" container
holds the configured values, while the "state" container holds the
operational values.  The duplication of hierarchies is removed, but
this strategy does not handle the existence of operational data for
which there is no configuration data, such as the system-created data
and deleted peers scenarios discussed above.

** Revised Datastores

The revised datastores architecture addresses these problems with
NETCONF by creating a distinct datastore for operational data, called
<operational>.  When retrieving data from <operational>, all currently
"in use" values are returned.  This allows modelers to use a single
hierarchy for both configuration and operational data, without
concerns about missing vital operational data.

In addition, another datastore named <intended> is defined that gives
a complete view of the configuration data, even in the presence of
device-specific features that expand or remove configuration data.
While such mechanisms are currently non-standard, the RDA recognizes
they exist and need to be handled appropriately.  In the future, such
mechanisms may become standardized.

The RDA also deprecates the <get> operation, removing the source of
these issues.

** Guidelines for Modelers

The following guidelines are meant to help modelers develop models
that will maximize the utility of the model with both current
implementations and RDA-capable implementations.

The direction taken should be based on both the maturity of the data
model, along with the number of concrete implementations of the model.
The intent is not to destabilize the IETF modeling community, but to
create models that can take advantage of the RDA.

When evaluating the impact to a particular data model, the following
guidelines should be considered:

(a) For new models or models with a sufficiently long development time
line, the model should target the RDA, with the expectation that their
models will be used by RDA-capable implementations and their
operational data will be available via the <operational> datastore.

(b) For models under development that have no serious dependency on
operational data, the model should also target the RDA, since the
impact would be minimal.  When RDA-capable implementations arrived,
the operational data will be available in the <operational> datastore.

(c) For models under development that need visibility into their
operational values and are not able to delay for the RDA-capable
implementations, a "state" container should be created that will
contain "config false" nodes corresponding to any "config true" nodes
for which operational values are needed.  Any other "config false"
nodes can be placed as siblings to the "config true" nodes.  In the
future, these "state" containers can be marked as deprecated, since
the <operational> datastore will provide those values.

(d) For models under development that currently use distinct "config"
and "state" containers to segregate operational values, the modeler
has a difficult decision, since the current structure is not
well-aligned to the future.  Whenever possible, the model should be
restructured in an RDA-compatible manner, but where the maturity of
the model and the active development work makes that problematic, the
impact for RDA-capable implementations will be duplication of
operational state under both "config" and "state" in the <operational>
datastore.

(e) For models under development that are using the top-level state
container (aka "/foo-state"), the modeler has a difficult decision,
since the current structure is not well-aligned to the future.
Whenever possible, the model should be restructured, moving nodes from
the "/foo-state" to an appropriate location within the "/foo"
hierarchy.
- For state nodes which have no corresponding "config true" node,
move the nodes to the corresponding node within the primary tree.
- For state nodes which have a corresponding "config true" node,
move the nodes under a "state" container that is peer to the "config
true" node.

(f) There are models for which the revised datastore structure makes
little sense, e.g. because the operational data is organized in a
completely different structure than the configuration data.  [Need
example.]  For such models, retaining a distinct "/foo-state"
hierarchy may continue to make sense.

(g) For models that augment other models, the modeler will have to
consider the structure of the base model and the guidelines listed
above.  In general, augmenting "state" containers should be avoided,
with the expectation that the base model will be re-released with any
state containers marked as deprecated.

It is critical to consider these as guidelines, understanding that our
goal is to make models that will see continued use in the long term.
We will need to balance short term needs against a desire for consistent
and usable models in the future.

One additional consideration: publishing a model for a distinct
"/foo-state" tree means that even implementations that are RDA-capable
will be forced to duplicate operational state under that hierarchy.
Modelers might consider marking their "/foo-state" hierarchy as "status
deprecated" to allow RDA-capable implementations to avoid the cost of
duplicating those nodes.  Non-RDA-capable implementations would
implement them as a means of allowing access to these operational
values.  This decision would need to taken into account the
progress of the RDA and the availability of RDA-capable
implementations. 
