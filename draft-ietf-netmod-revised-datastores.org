# -*- org -*-

Datastores are a fundamental concept binding the YANG data modeling
language to protocols transporting data defined in YANG data models,
such as NETCONF or RESTCONF.  This document defines a
conceptual model of datastores based on the experience gained with the
initial simpler model and addressing requirements that were not well
supported in the initial model.

* Introduction

This document provides an architectural framework for
datastores as they are used by network management protocols such as
NETCONF ^RFC6241^, RESTCONF ^RFC8040^ and the YANG
^RFC7950^ data modeling language.  Datastores are a fundamental concept
binding management data models to network management protocols and
agreement on a common architectural model of datastores ensures that
data models can be written in a network management protocol agnostic
way.  This architectural framework identifies a set of conceptual
datastores but it does not mandate that all network management
protocols expose all these conceptual datastores.  Furthermore, the
architecture does not detail how data is encoded by network management
protocols.

* Terminology

This document defines the following terms:

- configuration data: Data that determines how a device behaves.
  Configuration data can originate from different sources.
- static configuration data: Configuration data that is eventually
  persistent and used to get a device from its initial default state
  into its desired operational state.
- dynamic configuration data: Configuration data that is obtained
  dynamically during the operation of a device through interaction
  with other systems and not persistent.
- system configuration data: Configuration data that is supplied by
  the device itself.
- data-model-defined configuration data: Configuration data that is not
  explicitly provided but for which a value defined in the data model
  is used.
- applied configuration data: Configuration data that is currently
  used by a device. Applied configuration data consists of static
  configuration data and dynamic configuration data.
- state data: The additional data on a system that is not
  configuration data such as read-only status information and
  collected statistics. State data is transient and modified by
  interactions with internal components or other systems.
- datastore: A conceptual place to store and access information.  A
  datastore might be implemented, for example, using files, a
  database, flash memory locations, or combinations thereof.
- configuration datastore: A datastore holding static configuration
  data that is required to get a device from its initial default state
  into a desired operational state.
- running configuration datastore: A configuration datastore holding
  the complete static configuration currently active on the device.
  The running configuration datastore always exists. It may include
  inactive configuration or template configuration that require
  further expansion.
- intended configuration datastore: A configuration datastore holding
  the complete configuration currently active on the device. It does
  not include inactive configuration and it does include the expansion
  of any templates.
- candidate configuration datastore: A configuration datastore that
  can be manipulated without impacting the device's running
  configuration datastore and that can be committed to the running
  configuration datastore. Only present on devices that support and
  expose candidate configuration datastores.
- startup configuration datastore: The configuration datastore holding
  the configuration loaded by the device into the running
  configuration datastore when it boots. Only present on devices that
  separate the startup configuration datastore from the running
  configuration datastore.
- control-plane datastore: A datastore holding dynamic configuration
  data.
- applied configuration datastore: A datastore holding the currently
  active applied configuration data.
- operational state datastore: A datastore holding the currently
  active applied configuration data as well as the device's state
  data.

The following additional terms are not datastore specific but commonly
used and thus defined here as well:

- client: An entity that can access YANG-defined data on a server,
  over some network management protocol.
- server: An entity that provides access to YANG-defined data to a
  client, over some network management protocol.
- notification: A server-initiated message indicating that a certain
  event has been recognized by the server.
- remote procedure call: An operation that can be invoked by a client
  on a server.

Relationship to YANG 1.1 ^RFC7950^:

- Configuration data maps to all schema nodes marked "config true".
- Data-model-defined configuration data maps to schema nodes with an
  explicit default statement or an explanation in the description
  statement how a default value is determined.
- A datastore maps to an instantiated YANG data tree.
- A configuration datastore maps to an instantiated YANG data tree
  consisting of configuration data nodes and interior data nodes.

* Background

NETCONF ^RFC6241^ provides the following definitions:

- datastore: A conceptual place to store and access information.  A
  datastore might be implemented, for example, using files, a
  database, flash memory locations, or combinations thereof.
- configuration datastore: The datastore holding the complete set of
  configuration data that is required to get a device from its initial
  default state into a desired operational state.

YANG 1.1 ^RFC7950^ provides the following
refinements when NETCONF is used with YANG (which is the usual case
but note that NETCONF was defined before YANG did exist):

- datastore: When modeled with YANG, a datastore is realized as an
  instantiated data tree.
- configuration datastore: When modeled with YANG, a configuration
  datastore is realized as an instantiated data tree with
  configuration data.

RFC 6244 defined operational state data as follows:

- Operational state data is a set of data that has been obtained by
  the system at runtime and influences the system's behavior similar
  to configuration data.  In contrast to configuration data,
  operational state is transient and modified by interactions with
  internal components or other systems via specialized protocols.

Section 4.3.3 of RFC 6244 discusses operational state and among other
things mentions the option to consider operational state as being
stored in another datastore.  Section 4.4 of this document then
concludes that at the time of the writing, modeling state as a
separate data tree is the recommended approach.

Implementation experience and requests from operators
^I-D.ietf-netmod-opstate-reqs^, ^I-D.openconfig-netmod-opstate^
indicate that the datastore model initially designed for NETCONF and
refined by YANG needs to be extended.  In particular, the notion of
intended configuration and applied configuration has developed.

Furthermore, separating operational state data from configuration data
in a separate branch in the data model has been found operationally
complicated.  The relationship between the branches is not machine
readable and filter expressions operating on configuration data and on
related operational state data are different.

** Original Model of Datastores

The following drawing shows the original model of datastores as it is
currently used by NETCONF ^RFC6241^:

#+BEGIN_EXAMPLE
  +-------------+                 +-----------+
  | <candidate> |                 | <startup> |
  |  (ct, rw)   |<---+       +--->| (ct, rw)  |
  +-------------+    |       |    +-----------+
         |           |       |           |
         |         +-----------+         |
         +-------->| <running> |<--------+
                   | (ct, rw)  |
                   +-----------+
                         |
                         v
                  operational state  <--- control plane
                      (cf, ro)

  ct = config true; cf = config false
  rw = read-write; ro = read-only
  boxes denote datastores

#+END_EXAMPLE

Note that read-only (ro) and read-write (rw) is to be understood at a
conceptual level.  In NETCONF, for example, support for the <candidate>
and <startup> datastores is optional and the <running> datastore does
not have to be writable.  Furthermore, the <startup> datastore can only
be modified by copying <running> to <startup> in the standardized
NETCONF datastore editing model.  The RESTCONF protocol does not expose
these differences and instead provides only a writable unified
datastore, which hides whether edits are done through a <candidate>
datastore or by directly modifying the <running> datastore or via some
other implementation specific mechanism.  RESTCONF also hides how
configuration is made persistent.  Note that implementations may also
have additional datastores that can propagate changes to the <running>
datastore.  NETCONF explicitly mentions so called named datastores.

Some observations:

- Operational state has not been defined as a datastore although there
  were proposals in the past to introduce an operational state
  datastore.
- The NETCONF <get/> operation returns the content of the <running>
  configuration datastore together with the operational state.  It is
  therefore necessary that config false data is in a different branch
  than the config true data if the operational state data can have a
  different lifetime compared to configuration data or if
  configuration data is not immediately or successfully applied.
- Several implementations have proprietary mechanisms that allow
  clients to store inactive data in the <running> datastore; this
  inactive data is only exposed to clients that indicate that they
  support the concept of inactive data; clients not indicating support
  for inactive data receive the content of the <running> datastore
  with the inactive data removed.  Inactive data is conceptually
  removed during validation.
- Some implementations have proprietary mechanisms that allow clients
  to define configuration templates in <running>.  These templates
  are expanded automatically by the system, and the resulting
  configuration is applied internally.
- Some operators have reported that it is essential for them to be
  able to retrieve the configuration that has actually been
  successfully applied, which may be a subset or a superset of the
  <running> configuration.

* Architectural Model of Datastores @datastore-model@

Below is a new conceptual model of datastores extending the original
model in order reflect the experience gained with the original model.

#+BEGIN_EXAMPLE
  +-------------+                 +-----------+
  | <candidate> |                 | <startup> |
  |  (ct, rw)   |<---+       +--->| (ct, rw)  |
  +-------------+    |       |    +-----------+
         |           |       |           |
         |         +-----------+         |
         +-------->| <running> |<--------+
                   | (ct, rw)  |
                   +-----------+
                         |
                         |        // e.g., removal of 'inactive'
                         |        // nodes, expansion of templates
                         v
                   +------------+
                   | <intended> | // subject to validation
                   | (ct, ro)   |
                   +------------+
                         |
                         |        // e.g. missing resources, delays
                         |
                         |   +------ auto-discovery
                         |   +------ dynamic configuration protocols
                         |   +------ control-plane protocols
                         |   +------ control-plane datastores
                         |   |
                         v   v
                 +---------------+
                 | <operational> |
                 | (ct + cf, ro) |
                 +---------------+

  ct = config true; cf = config false
  rw = read-write; ro = read-only
  boxes denote datastores

#+END_EXAMPLE

The model foresees control-plane datastores that are by definition not
part of the persistent configuration of a device.  In some contexts,
these have been termed ephemeral datastores since the information is
ephemeral, i.e., lost upon reboot.  The control-plane datastores
interact with the rest of the system through the <operational>
datastore.  Note that the ephemeral datastore discussed in I2RS
documents maps to a control-plane datastore in the datastore
model described here.

** The <intended> datastore

The <intended> datastore is a read-only datastore that consists of
config true nodes.  It is tightly coupled to <running>.  When data is
written to <running>, the data that is to be validated is also
conceptually written to <intended>.  Validation is performed on the
contents of <intended>.

On a traditional NETCONF implementation, <running> and <intended> are
always the same.

Currently there are no standard mechanisms defined that affect
<intended> so that it would have different contents than <running>,
but this architecture allows for such mechanisms to be defined.

One example of such a mechanism is support for marking nodes as
inactive in <running>.  Inactive nodes are not copied to <intended>,
and are thus not taken into account when validating the
configuration.

Another example is support for templates.  Templates are expanded
when copied into <intended>, and the result is validated.


** The <operational> datastore

The <operational> datastore is a read-only datastore that
consists of config true and config false nodes.  In the original
NETCONF model the operational state only had config false nodes.  The
reason for incorporating config true nodes here is to be able to
expose all operational settings without having to replicate
definitions in the data models.

The <operational> datastore contains all configuration data actually
used by the system, i.e., all applied configuration, system
configuration and data-model-defined configuration.  In addition,
the <operational> datastore also contains state data.

In the <operational> datastore, semantic constraints defined
in the data model are not applied.  See ^issues^.

*** Missing Resources

Sometimes parts of <intended> configuration refer to resources
that are not present and hence parts of the <intended> configuration
cannot be applied.  A typical example is an interface configuration
that refers to an interface that is not currently present.  In such a
situation, the interface configuration remains in <intended> but the
interface configuration will not appear in <operational>.

*** System-controlled Resources

Sometimes resources are controlled by the device and such system
controlled resources appear in (and disappear from) <operational>
dynamically.  If a system controlled resource has matching
configuration in <intended> when it appears, the system will
try to apply the configuration, which causes the configuration to
appear in <operational> eventually (if application of the
configuration was successful).

*** Origin Metadata Annotation

As data flows into the <operational> datastore, it is conceptually
marked with a metadata annotation (^RFC7952^) that indicates its
origin.  The "origin" metadata annotation is defined in ^yang-module^.
 The values are YANG identities.  The following identities are defined:

  +-- origin
      +-- static
      +-- dynamic
      +-- data-model
      +-- system

These identities can be further refined, e.g., there might be an
identity "dhcp" derived from "dynamic".



* Guidelines for Defining Control-Plane Datastores. @guidelines@

The definition of a control-plane datastore SHOULD be provided in a
document (e.g., an RFC) purposed to the definition of the control-plane
datastore.  When it makes sense, more than one control-plane datastore
MAY be defined in the same document (e.g., when the datastores are
logically connected).  Each control-plane datastore's definition
SHOULD address the points specified in the sections below.

** Define a name for the control-plane datastore. @def-name@

Each control-plane datastores MUST have a name using the character set
described by Section 6.2 of ^RFC7950^.  The name SHOULD be consistent
in length to other datastore names described in this document (i.e.
less than 12 characters).

The datastore's name does not need to be globally unique, as it will
be uniquely qualified by the namespace of the module in which it is
defined (^def-module^).  This means that names such as "running" and
"operational" are valid datastore names.

** Define which YANG modules can be used in the datastore.

Not all YANG modules may be used in all datastores.  Some datastores may
constrain which data models can be used in them.  If it is desirable that
a subset of all modules can be targeted to the control-plane datastore,
then the documentation defining the control-plane datastore MUST use the
mechanisms described in ^yang-lib-impl^ to provide the necessary hooks for
module-designers to indicate that their module is to be accessible in the
control-plane datastore.

** Define which subset of YANG-modeled data applies.

By default, the data in a control-plane datastore is modeled by all
YANG statements in the available YANG modules.  However, it is
possible to specify criteria YANG statements must satisfy in order to
be present in a control-plane datastore.  For instance, maybe only
config true nodes are present, or config false nodes that also have a
specific YANG extension (e.g., ephemeral true) are present in the
control-plane datastore.

** Define how control-plane data is actualized.

The diagram in ^datastore-model^ depicts control-plane datastores
feeding into the <operational> datastore.  How this interaction
occurs must be defined by the control-plane datastore.  In some
cases, it may occur implicitly, as soon as the data is put into
the control-plane datastore while, in other cases, an explicit
action (e.g., an RPC) may be required to trigger the application
of the control-plane datastore's data.

** Define which protocols can be used.

By default, it is assumed that both the NETCONF and RESTCONF
protocols can be used to interact with a control-plane datastore.
However, it may be that only a specific protocol can be used
(e.g., Forces) or that a subset of all protocol operations or
capabilities are available (e.g., no locking, no xpath-based
filtering, etc.).

** Define a module for the control-plane datastore. @def-module@

Each control-plane datastore MUST be defined by a YANG module.
This module is used by servers to indicate (e.g., via YANG Library)
their support for the control-plane datastore.

It is RECOMMENDED that IETF module names follow the convention
"ietf-ds-<datastore-name>".  Though it is understood that this
convention places a uniqueness constraint of datastore names
(^def-name^) defined by the IETF.

The YANG module MUST import the "ietf-datastores" module, defined
in this document.  This is necessary in order to access the base
identities it defines.

The YANG module MUST define an identity that uses the 'datastore'
identity as its base.  This identity is necessary so that the datastore
can be referenced in protocol operations (e.g., <get-data>).

The YANG module MUST define an identity that uses the 'dynamic'
identity as its base.  This identity is necessary so that data
originating from the datastore can be identified as such via
the 'origin' metadata attribute define in ^yang-module^.

An example of these guidelines in use is provided in 
^ephemeral-ds-example^.


* YANG Module @yang-module@

!! include-figure ietf-datastores.yang extract-to="ietf-datastores@2016-10-13.yang"


* IANA Considerations @iana-con@

** Updates to the IETF XML Registry

This document registers one URI in the IETF XML registry ^RFC3688^.  Following
the format in ^RFC3688^, the following registration is requested:

   URI: urn:ietf:params:xml:ns:yang:ietf-datastores
   Registrant Contact: The NETMOD WG of the IETF.
   XML: N/A, the requested URI is an XML namespace.

** Updates to the YANG Module Names Registry

This document registers one YANG module in the YANG Module Names registry
^RFC6020^.  Following the format in ^RFC6020^, the the following registration
is requested:

   name:         ietf-datastores
   namespace:    urn:ietf:params:xml:ns:yang:ietf-datastores
   prefix:       ds
   reference:    RFC XXXX


* Security Considerations @sec-con@

This document discusses a conceptual model of datastores for network
management using NETCONF/RESTCONF and YANG.  It has no security impact
on the Internet.

* Acknowledgments

This document grew out of many discussions that took place since 2010.
Several Internet-Drafts (^I-D.bjorklund-netmod-operational^,
^I-D.wilton-netmod-opstate-yang^, ^I-D.ietf-netmod-opstate-reqs^,
^I-D.kwatsen-netmod-opstate^, ^I-D.openconfig-netmod-opstate^) and
^RFC6244^ touched on some of the problems of the original datastore
model.  The following people were authors to these Internet-Drafts or
otherwise actively involved in the discussions that led to this
document:

- Lou Berger, LabN Consulting, L.L.C., <lberger@labn.net>
- Andy Bierman, YumaWorks, <andy@yumaworks.com>
- Marcus Hines, Google, <hines@google.com>
- Christian Hopps, Deutsche Telekom, <chopps@chopps.org>
- Acee Lindem, Cisco Systems, <acee@cisco.com>
- Ladislav Lhotka, CZ.NIC, <lhotka@nic.cz>
- Thomas Nadeau, Brocade Networks, <tnadeau@lucidvision.com>
- Anees Shaikh, Google, <aashaikh@google.com>
- Rob Shakir, Google, <robjs@google.com>

Juergen Schoenwaelder was partly funded by Flamingo, a Network of
Excellence project (ICT-318488) supported by the European Commission
under its Seventh Framework Programme.

*! start-appendix

* Example Data

In this example, the following fictional module is used:

!! include-figure example-system.yang

The operator has configured the host name and two interfaces, so the
contents of <intended> is:

!! include-figure ex-intended.load

The system has detected that the hardware for one of the configured
interfaces ("eth1") is not yet present, so the configuration for that
interface is not applied.  Further, the system has received a host name
and an additional IP address for "eth0" over DHCP.  In addition to a
default value, a loopback interface is automatically added by the system,
and the result of the "speed" auto-negotiation.  All of this is reflected
in <operational>:

!! include-figure ex-oper.load


* Open Issues @issues@

+ How do we handle semantical constraints in <operational>?  Are
  they just ignored?  Do we need a new YANG statement to define if a
  "must" constraints applies to the <operational>?
+ Better name for "static configuration"?
+ Better name for "intended"?


* Ephemeral Control-Plane Datastore Example @ephemeral-ds-example@

The section defines documentation for an example control-plane
datastore using the guidelines provided in ^guidelines^.
While this example is very terse, it is expected to be that a
standalone RFC would be needed when fully expanded.

This example defines a control-plane datastore called :ephemeral,
which is loosely modeled after the work done in the I2RS working
group.

  1. Name            : ephemeral  (register with IANA)
  2. YANG modules    : all (default)
  3. YANG statements : config false + ephemeral true
  4. How applied     : automatic
  5. Protocols       : NC/RC (default)
  6. YANG Module     : (see below)

  module ietf-ds-ephemeral {
    namespace "urn:ietf:params:xml:ns:yang:ietf-ds-ephemeral";
    prefix e;

    import ietf-datastores {
      prefix ds;
    }

    // add datastore identity
    identity ds-ephemeral {
      base ds:datastore;
      description
        "The 'ephemeral' datastore.";
    }

    // add origin identity
    identity or-ephemeral {
      base ds:dynamic;
      description
        "Denotes data from the ephemeral control-plane datastore.";
    }
  }



* Implications on Data Models

Since the NETCONF <get/> operation returns the content of the
<running> configuration datastore and the operational state together
in one tree, data models were often forced to branch at the top-level
into a config true branch and a structurally similar config false
branch that replicated some of the config true nodes and added state
nodes.  With the datastore model described here this is not needed
anymore since the different datastores handle the different lifetimes
of data objects.  Introducing this model together with the deprecation
of the <get/> operation makes it possible to write simpler models.

** Proposed migration of existing YANG Data Models

For standards based YANG modules that have already been published,
that are using split config and state trees, it is planned that these
modules are updated with new revisions containing the following
changes:

- The top level module description is updated to indicate that the
  module conforms to the revised datastore architecture with a
  combined config and state tree, and that the existing state tree
  nodes are deprecated, to be obsoleted over time.

- All status 'current' data nodes under the existing 'state' trees are
  copied to the equivalent place under the 'config' tree:

  - If a node with the same name and type already exists under the
    equivalent path in the config tree then the nodes are merged and
    the description updated.

  - If a node with the same name but different type exists under the
    equivalent path in the config tree, then the module authors must
    choose the appropriate mechanism to combine the config and state
    nodes in a backwards compatible way based on the data model design
    guidelines below.  This may require the state node to be added to
    the config tree with a modified name.  This scenario is expected
    to be relatively uncommon.

  - If no node with the same name and path already exists under the
    config tree then the state node schema is copied verbatim into the
    config tree.

  - As the state nodes are copied into the config trees, any
    leafrefs that reference other nodes in the state tree are adjusted
    to reference the equivalent path in the config tree.

  - All status 'current' nodes under the existing 'state' trees are
    marked as 'status' deprecated.

- Augmentations are similarly handled to data nodes as described
  above.

** Standardization of new YANG Data Models:

New standards based YANG modules, or those in active development,
should be designed to conform to the revised datastore architecture,
following the design guidelines described below, and only need to
provide combined config/state trees.



* Implications on other Drafts

The sections below describe the authors' thoughts on how various other
drafts may be updated to support the datastore architecture described
 in this draft.  They have been incorporated as an appendix of this document
to facilitate easier review, but the expectation is that this work will be
moved into another document as soon as the appropriate working group
decides to take on the work.



** Implications on YANG

Note: This section describes the authors' thoughts on how YANG ^RFC7950^
could be updated to support the datastore architecture described in this
draft.  It has been incorporated here as a temporary measure to 
facilitate easier review, but the expectation is that this work will be
moved into another document as soon as the NETMOD WG decides to take on
the work.

- Some clarifications may be needed if this datastore model is
  adopted.  YANG currently describes validation in terms of the
  <running> configuration datastore while it really happens on the
  <intended> configuration datastore.

- [DISCUSS: We need to discuss somewhere how remote procedure calls
  and notifications/actions tie into datastores RFC 7950 shows as an
  example a ping action tied to an interface. Does this refer to an
  interface defined in a configuration datastore? Or an interface
  defined in the operational state datastore? Or the applied
  configuration datastore? Similarly, RFC 7950 shows an example of a
  link-failure notification; this likely applies implicitly to the
  operational state datastore. The netconf-config-change notification
  does explicitly identify a datastore. I think we generally need to
  have remote procedure calls and notifications be explicit about which
  datastores they apply to and perhaps change the default xpath context
  from running plus state to the operational state datastore.]



** Implications on YANG Library @yang-lib-impl@

Note: This section describes the authors' thoughts on how YANG Library
^RFC7895^ could be updated to support the datastore architecture described
in this draft.  It has been incorporated here as a temporary measure
to facilitate easier review, but the expectation is that this work will
be owned and standardized via the NETCONF working group.

[TBD (mbj)] FIXME



** Implications to YANG Guidelines 

Note: This section describes the authors' thoughts on how Guidelines for
Authors and Reviewers of YANG Data Model Documents ^I-D.ietf-netmod-rfc6087bis^
could be updated to support the datastore architecture described in this draft.
It has been incorporated here as a temporary measure to facilitate easier
review, but the expectation is that this work will be owned and standardized via
the NETCONF working group.

It is important to design data models with clear semantics that work
equally well for instantiation in a configuration datastore and
instantiation in the <operational> datastore.

*** Nodes with different config/state value sets

There may be some differences in the value set of some nodes that are
used for both configuration and state.  At this point of time, these
are considered to be rare cases that can be dealt with using different
nodes for the configured and state values.

*** Auto-configured or Auto-negotiated Values

Sometimes configuration leafs support special values that instruct the
system to automatically configure a value.  An example is an MTU that
is configured to 'auto' to let the system determine a suitable MTU
value.  Another example is Ethernet auto-negotiation of link speed.  In
such a situation, it is recommended to model this as two separate
leafs, one config true leaf for the input to the auto-negotiation
process, and one config false leaf for the output from the process.



** Implications on NETCONF

Note: This section describes the authors' thoughts on how NETCONF ^RFC6241^ could be
updated to support the datastore architecture described in this draft.
It has been incorporated here as a temporary measure to facilitate
easier review, but the expectation is that this work will be owned and
standardized via the NETCONF working group.

*** Introduction

The NETCONF protocol ^RFC6241^ defines a simple mechanism through
which a network device can be managed, configuration data information
can be retrieved, and new configuration data can be uploaded and
manipulated.

NETCONF already has support for configuration datastores, but it does
not define an operational datastore.  Instead, it provides the <get>
operation that returns the contents of the <running> datastore along
with all config false leaves.  However, this <get> operation is
incompatible with the new datastore architecture defined in this
document, and hence should be deprecated.

There are two possible ways that NETCONF could be extended to support
the new architecture: Either as new optional capabilities extending
the current version of NETCONF (v1.1, ^RFC6241^), or by defining a new
version of NETCONF.

Many of the required additions are common to both approaches, and are
described below.  A following section then describes the benefits of
defining a new NETCONF version, and the additional changes that would
entail.

*** Overview of additions to NETCONF

- A new "supported datastores" capability allows a device to list all
  datastores it supports.  Implementations can choose which datastores
  they expose, but MUST at least expose both the <running> and
  <operational> datastores.  They MAY expose additional datastores,
  such as <intended>, <candidate>, etc.

- A new <get-data> operation is introduced that allows the client
  to return the contents of a datastore.  For configuration
  datastores, this operation returns the same data that would be
  returned by the existing <get-config> operation.

- A new "metadata-filter" capability allows a device to indicate that
  it supports queries using YANG metadata as a <filter> element.
  E.g. <filter type=metadata/> in <get> and <get-config> requests.

 - DISCUSS, does the capability need to be able to differentiate between
   different types of YANG metadata?  [Move to Open Issue, perhaps add
   to new <get-data> operation?]

- A new "with-metadata" capability allows a device to indicate that it
  supports the capability of including YANG metadata annotations in
  the responses to <get> and <get-config> requests.  This is achieved
  in a similar way to with-defaults ^RFC6243^, by introducing a
  <with-metadata> XML element to <get> and <get-config> requests.

 - DISCUSS, does the capability, and XML element, need to be able to
   differentiate between different types of YANG metadata annotations?
   [should be controlled by a feature statement]

- The handling of defaults for the new configuration datastores is as
  described in with-defaults ^RFC6243^, but that does not apply for
  the operational state datastore that defines new semantics.

**** Operational State Datastore Defaults Handling

The normal semantics for the <operational> datastore are that
all values that match the default specified in the schema are included
in response to requests on the operational state datastore. This is
equivalent to the 'report-all' mode of the with-defaults handling.

The 'metadata-filter' query parameter can be used to exclude nodes
with origin metadata matching 'data-model', that would exclude nodes
that match the default value specified in the schema.

If the server cannot return a value for any reason (e.g. the server
cannot determine the value, or the value that would be returned is
outside the allowed leaf value range) then the server can choose to
not return any value for a particular leaf, which MUST be interpreted
by the client as the value of that leaf not being known, rather than
implicitly having the default value.

*** Overview of NETCONF version 2

This section describes NETCONF version 2, by explaining the
differences to NETCONF version 1.1.  Where not explicitly specified,
the behavior of NETCONF version 2 is the same as for NETCONF
version 1.1 ^RFC6241^.

**** Benefits of defining a new NETCONF version

Defining a new version of NETCONF (as opposed to extending NETCONF
version 1.1) has several benefits:

- It allows for removal of the existing <get> RPC operation, that
  returns content from both the running configuration datastore
  combined with all config false leaves.

- It could allow the existing <get-config> operation to also be
  removed, replaced by the more generic <get-data> that is named
  appropriately to also apply to the operational datastore.

- It makes it easier for clients and servers to know what reasonable
  common baseline functionality to expect, rather than a collection of
  capabilities that may not be implemented in a consistent fashion.
  In particular, clients will able to assume support for the
  <operational> datastore.

- It can gracefully coexist with NETCONF v1.  A server could implement
  both versions.  Existing YANG models exposing split config/state
  trees could be exposed via NETCONF v1.1, whereas combined
  config/state YANG models could be exposed via NETCONF v2, providing
  a viable server upgrade path.

**** Proposed changes for NETCONF v2

The differences between NETCONF v2 and NETCONF v1.1 can be summarized
as:

- NETCONF v2 advertises a new base NETCONF capability
  "urn:ietf:params:netconf:base:2.0".  A service may advertise older
  NETCONF versions as well, to allow a client to choose which version
  to use.

- NETCONF v2 removes support for the existing <get> operation, that is
  replaced by the <get-data> on the operational datastore.

- NETCONF v2 can publish a separate version of YANG library from a
  NETCONF v1.1 implementation running on the same device, allowing
  different versions of NETCONF to support a different set of YANG
  modules.

**** Possible Migration Paths

A common approach in current data models is to have two separate trees
"/foo" and "/foo-state", where the former contains config true nodes,
and the latter config false nodes.  A data model that is designed for
the revised architectural framework presented in this document will
have a single tree "/foo" with a combination of config true and config
false nodes.

Two different migration strategies are considered:

***** Migration Path using two instances of NETCONF

If, for backwards compatability reasons, a server intends to support both
split config/state trees and the combined config/state trees proposed
in this architecture, then this can be achieved by having the device
support both NETCONF v1 and NETCONF v2 at the same time:

 - The NETCONF v1 implementation could support existing YANG module
   revisions defined with split config/state trees.

 - The NETCONF v2 implementation could support different YANG
   modules, or YANG module revisions, with combined config/state
   trees.

Clients can then decide on which type of models to use by expressing
the appropriate version of the base NETCONF capability during
capability exchange.

***** Migration Path using a single instance of NETCONF

The proposed strategy for updating existing published data models is
to publish new revisions with the state trees' nodes copied under the
config tree, and for the existing state trees to have all of their
nodes marked as deprecated.  The expectation is that NETCONF servers
would use a combination of these updated models alongside new models
that only follow the new datastore architecture.

- NETCONF servers can support clients that are not aware of the
revised datastore architecture, particularly if they continue to
support the deprecated <get> operation:

 - For updated YANG modules they would see additional information
   returned via the <get> operation.

 - For new YANG modules, some of the state nodes may not be available,
   i.e. for any state nodes that exist under a config node that has
   not been configured (e.g. statistics under a system created
   interface).

- NETCONF servers can also support clients that are aware of the
  revised datastores architecture:

 - For updated YANG modules they would see additional information
   returned under the legacy state trees.  This information can be
   excluded using appropriate subtree filters.

 - New YANG modules, conforming to the datastores architecture, would
   work exactly as expected.



** Implications on RESTCONF

This section describes the authors' thoughts on how RESTCONF ^RFC8040^ could be
updated to support the datastore architecture described in this draft.
It has been incorporated here as a temporary measure to facilitate
easier review, but the expectation is that this work will be owned and
standardized via the NETCONF working group.

*** Introduction

RESTCONF ^RFC8040^ defines a protocol based on HTTP for configuring
data defined in YANG version 1 or 1.1, using a conceptual datastore
that is compatible with a server that implements NETCONF 1.1 compliant
datastores.

The combined conceptual datastore defined in RESTCONF is incompatible
with the new datastore architecture defined in this document. There
are two possible ways that RESTCONF could be extended to support the
new architecture: Either as new optional capabilities extending the
existing RESTCONF RFC, or as an new version of RESTCONF.

Many of the required additions are common to both approaches, and are
described below.  A following section then describes the benefits of
defining a new RESTCONF version, and the additional changes that would
entail.

*** Overview of additions to RESTCONF

- A new path {+restconf}/datastore/<datastore-name>/data/
  to provide a YANG data tree for each datastore that is exposed via
  RESTCONF.

- Implementations can choose which datastores they expose, but MUST at
  least expose both the <running> and <operational> datastores.  They
  MAY expose the <intended> datastores as needed.

- The same HTTP Methods supported on {+restconf}/data/ are also
  supported on {+restconf}/datastore/<datastore-name>/data/ but
  suitably constrained depending on whether the datastore can be
  written to by the client, or is read-only.

- The same query parameters supported on {+restconf}/data/ are also
  support on {+restconf}/datastore/<datastore-name>/data/ except for
  the following query parameters:

 - 'content' - is not supported on any of the new datastore paths.

 - 'metadata' - is a new optional query parameter that filters the
   returned data based on the metadata annotation.

 - 'with-metadata' - is a new optional query parameter that
   indicating that the metadata annotations should be included in the
   reply.

 - 'with-defaults' is supported on all configuration datastores, but
   is not supported on the operational state datastore path, because
   it has different default handling semantics.

- The handling of defaults (include the with-defaults query parameter)
  for the new configuration datastores is the same as the existing
  conceptual datastore, but does not apply for the operational state
  datastore that defines new semantics.

**** HTTP Methods

All configuration datastores support all HTTP Methods.

The <operational> datastore only supports the following HTTP methods:
OPTIONS, HEAD, GET, and POST to invoke an RFC operation.

**** Query parameters

The 'content' query parameter is not supported by any of the new
datastores because its functionality has been obsoletely by the
revised datastores architecture.

[DISCUSS, actually, is there any harm in leaving the 'content' query parameter as is?]
- we agreed to leave the 'content' param in for now.

^RFC7952^ specifies how a YANG data tree can be annotated with generic
metadata information, that is used by this document to annotate data
nodes with origin information indicating the mechanism by which the
operational value came into effect.

RESTCONF could be extended with an optional generic mechanism to allow
the filtering of nodes returned in a query based on metadata
annotations associated with the data node.

RESTCONF could also be extended with an optional generic mechanism to
choose whether metadata annotations should be included in the
response, potentially filtering to a subset of annotations.  E.g. only
include @origin metadata annotations, and not any others that may be
in use.

Both of the generic mechanisms could be controlled by a new capability.
A new capability is defined to indicate whether a device supports
filtering on, or annotating responses with, the origin meta data.



**** Operational State Datastore Defaults Handling

The normal semantics for the <operational> datastore are that
all values that match the default specified in the schema are included
in response to requests on the operational state datastore. This is
equivalent to the 'report-all' mode of the with-defaults handling.

The 'metadata' query parameter can be used to exclude nodes with a
origin metadata matching 'data-model', that would exclude (only
config true?) nodes that match the default value specified in the
schema.

If the server cannot return a value for any reason (e.g. the server
cannot determine the value, or the value that would be returned is
outside the allowed leaf value range) then the server can choose to
not return any value for a particular leaf, which MUST be interpreted
by the client as the value of that leaf not being known, rather than
implicitly having the default value.

*** Overview of RESTCONF version 2

This section describes RESTCONF version 2, by explaining the
differences to RESTCONF version 1.  Where not explicitly specified,
the behavior of RESTCONF version 2 is the same as for RESTCONF
version 1 ^RFC8040^.

**** Benefits of defining a new RESTCONF version

Defining a new version of RESTCONF (as opposed to extending RESTCONF
version 1) has several benefits:

- It exposes datastores, and models designed for the revised datastore
  architecture, in a clean and consistent way.

- It allows the parts of RESTCONF that do not work well with the
  revised datastore architecture to be omitted from RESTCONF v2.

- It makes it easier for clients and servers to know what reasonable
  common baseline functionality to expect, rather than a collection of
  capabilities that may not be implemented in a consistent fashion.

- It can gracefully coexist with RESTCONF v1.  A server could implement both
  versions.  Existing YANG models exposing split config/state trees
  could be exposed via RESTCONF v1, whereas combined config/state YANG models
  could be exposed via RESTCONF v2, providing a viable server upgrade path.

**** Proposed changes for RESTCONF v2

The differences between RESTCONF version 2 (RESTCONF v2) and RESTCONF
version 1 (RESTCONF v1) ^RFC8040^ can be summarized as:

- RESTCONF v2 defines a new root resource (referred to as
{+restconf2}, and a separate link relation in the
/.well-known/host-meta resource.

- RESTCONF v2 removes support for the {+restconf}/data path supported
  in RESTCONF v1.

- RESTCONF v2 removes support for the content query parameter, since
  it no longer useful in the revised datastore architecture.

- RESTCONF v2 can publish a separate version of YANG library from a
  RESTCONF v1 implementation running on the same device, allowing
  different versions of RESTCONF to support a different set of YANG
  modules.

**** Possible Migration Path using RESTCONF v2

A common approach in current data models is to have two separate trees
"/foo" and "/foo-state", where the former contains config true nodes,
and the latter config false nodes.  A data model that is designed for
the revised architectural framework presented in this document will
have a single tree "/foo" with a combination of config true and config
false nodes.

If for backwards compatability reasons, a server intends to support both
split config/state trees, and the combined config/state trees proposed
in this architecture, then this can be achieved by having the device
support both RESTCONF v1 and RESTCONF v2 at the same time:

 - The RESTCONF v1 implementation could support existing YANG module
   revisions defined with split config/state trees.

 - The RESTCONF v2 implementation could support different YANG
   modules, or YANG module revisions, with combined config/state
   trees.

Clients can then decide on which type of models to use by choosing
whether to use the RESTCONF v1 root resource or the RESTCONF v2 root
resource.






{{document:
    name ;
    ipr trust200902;
    category std;
    references back.xml;
    title "Network Management Datastore Architecture";
    contributor "author:Martin Bjorklund:Tail-f Systems:mbj@tail-f.com";
    contributor "author:Juergen Schoenwaelder:Jacobs University:j.schoenwaelder@jacobs-university.de";
    contributor "author:Phil Shafer:Juniper Networks:phil@juniper.net";
    contributor "author:Kent Watsen:Juniper Networks:kwatsen@juniper.net";
    contributor "author:Rob Wilton:Cisco Systems:rwilton@cisco.com";
}}
