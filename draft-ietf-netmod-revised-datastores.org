# -*- org -*-

Datastores are a fundamental concept binding the YANG data modeling
language to protocols transporting data defined in YANG data models,
such as NETCONF or RESTCONF.  This document defines a
conceptual model of datastores based on the experience gained with the
initial simpler model and addressing requirements that were not well
supported in the initial model.

* Introduction

This document provides an architectural framework for
datastores as they are used by network management protocols such as
NETCONF ^RFC6241^, RESTCONF ^RFC8040^ and the YANG
^RFC7950^ data modeling language.  Datastores are a fundamental concept
binding management data models to network management protocols and
agreement on a common architectural model of datastores ensures that
data models can be written in a network management protocol agnostic
way.  This architectural framework identifies a set of conceptual
datastores but it does not mandate that all network management
protocols expose all these conceptual datastores.  Furthermore, the
architecture does not detail how data is encoded by network management
protocols.

* Terminology

This document defines the following terms:

- configuration data: Data that determines how a device behaves.
  Configuration data can originate from different sources.
- static configuration data: Configuration data that is eventually
  persistent and used to get a device from its initial default state
  into its desired operational state.
- dynamic configuration data: Configuration data that is obtained
  dynamically during the operation of a device through interaction
  with other systems and not persistent.
- system configuration data: Configuration data that is supplied by
  the device itself.
- data-model-defined configuration data: Configuration data that is not
  explicitly provided but for which a value defined in the data model
  is used.
- applied configuration data: Configuration data that is currently
  used by a device. Applied configuration data consists of static
  configuration data and dynamic configuration data.
- state data: The additional data on a system that is not
  configuration data such as read-only status information and
  collected statistics. State data is transient and modified by
  interactions with internal components or other systems.
- datastore: A conceptual place to store and access information.  A
  datastore might be implemented, for example, using files, a
  database, flash memory locations, or combinations thereof.
- configuration datastore: A datastore holding static configuration
  data that is required to get a device from its initial default state
  into a desired operational state.
- running configuration datastore: A configuration datastore holding
  the complete static configuration currently active on the device.
  The running configuration datastore always exists. It may include
  inactive configuration or template configuration that require
  further expansion.
- intended configuration datastore: A configuration datastore holding
  the complete configuration currently active on the device. It does
  not include inactive configuration and it does include the expansion
  of any templates.
- candidate configuration datastore: A configuration datastore that
  can be manipulated without impacting the device's running
  configuration datastore and that can be committed to the running
  configuration datastore. Only present on devices that support and
  expose candidate configuration datastores.
- startup configuration datastore: The configuration datastore holding
  the configuration loaded by the device into the running
  configuration datastore when it boots. Only present on devices that
  separate the startup configuration datastore from the running
  configuration datastore.
- control-plane datastore: A datastore holding dynamic configuration
  data.
- applied configuration datastore: A datastore holding the currently
  active applied configuration data.
- operational state datastore: A datastore holding the currently
  active applied configuration data as well as the device's state
  data.

The following additional terms are not datastore specific but commonly
used and thus defined here as well:

- client: An entity that can access YANG-defined data on a server,
  over some network management protocol.
- server: An entity that provides access to YANG-defined data to a
  client, over some network management protocol.
- notification: A server-initiated message indicating that a certain
  event has been recognized by the server.
- remote procedure call: An operation that can be invoked by a client
  on a server.

Relationship to YANG 1.1 ^RFC7950^:

- Configuration data maps to all schema nodes marked "config true".
- Data-model-defined configuration data maps to schema nodes with an
  explict default statement or an explanation in the decription
  statement how a default value is determined.
- A datastore maps to an instantiated YANG data tree.
- A configuration datastore maps to an instantiated YANG data tree
  consisting of configuration data nodes and interior data nodes.

* Background

NETCONF ^RFC6241^ provides the following definitions:

- datastore: A conceptual place to store and access information.  A
  datastore might be implemented, for example, using files, a
  database, flash memory locations, or combinations thereof.
- configuration datastore: The datastore holding the complete set of
  configuration data that is required to get a device from its initial
  default state into a desired operational state.

YANG 1.1 ^RFC7950^ provides the following
refinements when NETCONF is used with YANG (which is the usual case
but note that NETCONF was defined before YANG did exist):

- datastore: When modeled with YANG, a datastore is realized as an
  instantiated data tree.
- configuration datastore: When modeled with YANG, a configuration
  datastore is realized as an instantiated data tree with
  configuration data.

RFC 6244 defined operational state data as follows:

- Operational state data is a set of data that has been obtained by
  the system at runtime and influences the system's behavior similar
  to configuration data.  In contrast to configuration data,
  operational state is transient and modified by interactions with
  internal components or other systems via specialized protocols.

Section 4.3.3 of RFC 6244 discusses operational state and among other
things mentions the option to consider operational state as being
stored in another datastore.  Section 4.4 of this document then
concludes that at the time of the writing, modeling state as a
separate data tree is the recommended approach.

Implementation experience and requests from operators
^I-D.ietf-netmod-opstate-reqs^, ^I-D.openconfig-netmod-opstate^
indicate that the datastore model initially designed for NETCONF and
refined by YANG needs to be extended.  In particular, the notion of
intended configuration and applied configuration has developed.

Furthermore, separating operational state data from configuration data
in a separate branch in the data model has been found operationally
complicated.  The relationship between the branches is not machine
readable and filter expressions operating on configuration data and on
related operational state data are different.

** Original Model of Datastores

The following drawing shows the original model of datastores as it is
currently used by NETCONF ^RFC6241^:

#+BEGIN_EXAMPLE
  +-------------+                 +-----------+
  | <candidate> |                 | <startup> |
  |  (ct, rw)   |<---+       +--->| (ct, rw)  |
  +-------------+    |       |    +-----------+
         |           |       |           |
         |         +-----------+         |
         +-------->| <running> |<--------+
                   | (ct, rw)  |
                   +-----------+
                         |
                         v
                  operational state  <--- control plane
                      (cf, ro)

  ct = config true; cf = config false
  rw = read-write; ro = read-only
  boxes denote datastores

#+END_EXAMPLE

Note that read-only (ro) and read-write (rw) is to be understood at a
conceptual level.  In NETCONF, for example, support for the <candidate>
and <startup> datastores is optional and the <running> datastore does
not have to be writable.  Furthermore, the <startup> datastore can only
be modified by copying <running> to <startup> in the standardized
NETCONF datastore editing model.  The RESTCONF protocol does not expose
these differences and instead provides only a writable unified
datastore, which hides whether edits are done through a <candidate>
datastore or by directly modifying the <running> datastore or via some
other implementation specific mechanism.  RESTCONF also hides how
configuration is made persistent.  Note that implementations may also
have additional datastores that can propagate changes to the <running>
datastore.  NETCONF explicitly mentions so called named datastores.

Some observations:

- Operational state has not been defined as a datastore although there
  were proposals in the past to introduce an operational state
  datastore.
- The NETCONF <get/> operation returns the content of the <running>
  configuration datastore together with the operational state.  It is
  therefore necessary that config false data is in a different branch
  than the config true data if the operational state data can have a
  different lifetime compared to configuration data or if
  configuration data is not immediately or successfully applied.
- Several implementations have proprietary mechanisms that allow
  clients to store inactive data in the <running> datastore; this
  inactive data is only exposed to clients that indicate that they
  support the concept of inactive data; clients not indicating support
  for inactive data receive the content of the <running> datastore
  with the inactive data removed.  Inactive data is conceptually
  removed during validation.
- Some implementations have proprietary mechanisms that allow clients
  to define configuration templates in <running>.  These templates
  are expanded automatically by the system, and the resulting
  configuration is applied internally.
- Some operators have reported that it is essential for them to be
  able to retrieve the configuration that has actually been
  successfully applied, which may be a subset or a superset of the
  <running> configuration.

* Architectural Model of Datastores @datastore-model@

Below is a new conceptual model of datastores extending the original
model in order reflect the experience gained with the original model.

#+BEGIN_EXAMPLE
  +-------------+                 +-----------+
  | <candidate> |                 | <startup> |
  |  (ct, rw)   |<---+       +--->| (ct, rw)  |
  +-------------+    |       |    +-----------+
         |           |       |           |
         |         +-----------+         |
         +-------->| <running> |<--------+
                   | (ct, rw)  |
                   +-----------+
                         |
                         |        // e.g., removal of 'inactive'
                         |        // nodes, expansion of templates
                         v
                   +------------+
                   | <intended> | // subject to validation
                   | (ct, ro)   |
                   +------------+
                         |
                         |        // e.g., missing resources or
                         |        // delays
                         v
                   +-----------+
                   | <applied> |<---+--- dynamic configuration
                   | (ct, ro)  |    |      protocols
                   +-----------+    +--- control-plane datastores
                         |
                         |          +--- auto-discovery
                         |    +-----+--- control-plane protocols
                         |    |     +--- control-plane datastores
                         v    v
               +---------------------+
               | <operational-state> |
               | (ct + cf, ro)       |
               +---------------------+

  ct = config true; cf = config false
  rw = read-write; ro = read-only
  boxes denote datastores

#+END_EXAMPLE

The model foresees control-plane datastores that are by definition not
part of the persistent configuration of a device.  In some contexts,
these have been termed ephemeral datastores since the information is
ephemeral, i.e., lost upon reboot.  The control-plane datastores
interact with the rest of the system through the <applied> or
<operational-state> datastores, depending on the type of data they
contain.  Note that the ephemeral datastore discussed in I2RS
documents maps to a control-plane datastore in the datastore
model described here.

** The <intended> datastore

The <intended> datastore is a read-only datastore that consists of
config true nodes.  It is tightly coupled to <running>.  When data is
written to <running>, the data that is to be validated is also
conceptually written to <intended>.  Validation is performed on the
contents of <intended>.

On a traditional NETCONF implementation, <running> and <intended> are
always the same.

Currently there are no standard mechanisms defined that affect
<intended> so that it would have different contents than <running>,
but this architecture allows for such mechanisms to be defined.

One example of such a mechanism is support for marking nodes as
inactive in <running>.  Inactive nodes are not copied to <intended>,
and are thus not taken into account when validating the
configuration.

Another example is support for templates.  Templates are expanded
when copied into <intended>, and the result is validated.

** The <applied> datastore @applied-ds@

The <applied> datastore is a read-only datastore that consists of
config true nodes.  It contains the currently active configuration on
the device.  This data can come from several sources; from <intended>,
from dynamic configuration protocols (e.g., DHCP), or from
control-plane datastores.

As data flows into the <applied> and <operational-state> datastores,
it is conceptually marked with a metadata annotation (^RFC7952^) that
indicates its origin.  [DISCUSS: the following should be moved into
its own section] The "origin" metadata annotation is defined in
^module^.  The values are YANG identities.  The following identities
are defined:

  +-- origin
      +-- static
      +-- dynamic
      +-- data-model
      +-- system

These identities can be further refined, e.g., there might be an
identity "dhcp" derived from "dynamic".

The <applied> datastore contains the subset of the
instances in the <operational-state> datastore where the "origin"
values are derived from or equal to "static" or "dynamic".

*** Missing Resources

Sometimes some parts of <intended> configuration refer to resources
that are not present and hence parts of the <intended> configuration
cannot be applied.  A typical example is an interface configuration
that refers to an interface that is not currently present.  In such a
situation, the interface configuration remains in <intended> but the
interface configuration will not appear in <applied>.

*** System-controlled Resources

Sometimes resources are controlled by the device and such system
controlled resources appear in (and disappear from) the
<operational-state> dynamically.  If a system controlled resource has
matching configuration in <intended> when it appears, the system will
try to apply the configuration, which causes the configuration to
appear in <applied> eventually (if application of the configuration
was successful).

** The <operational-state> datastore

The <operational-state> datastore is a read-only datastore that
consists of config true and config false nodes.  In the original
NETCONF model the operational state only had config false nodes.  The
reason for incorporating config true nodes here is to be able to
expose all operational settings without having to replicate
definitions in the data models.

The <operational-state> datastore contains all configura data actually
used by the system, i.e., all applied configuration, system
configuration and data-model-defined configuration.  This data is marked with the
"origin" metadata annotation.  In addition, the <operational-state>
datastore also contains state data.

In the <operational-state> datastore, semantic constraints defined
in the data model are not applied.  See ^issues^.

* Guidelines for Defining Control-Plane Datastores @cp-ds-guidelines@

The following provides guidelines for control-plane datastore
designers.

** Define the control-plane datastore's name.

All datastores, including control-plane datastores, MUST have
a globally unique name.  To ensure this, all datastores MUST
register their names with IANA, along with the RFC number that
defined it.

[DISCUSS: how do they register their name?  identityref, enum, module name?
- if not module name, then we'll need to add an IANA Considerations section]


** Define which YANG modules can be used in the datastore.

Not all YANG modules may be used in all datastores.  Some datastores may
constrain which data models can be used in them.  Please see ^yang-lib-impl^
for details.

** Define which subset of YANG-modelled data applies.

By default, the data in a control-plane datastore is modeled by all
YANG statements in the available YANG modules.  However, it is
possible to specify criteria YANG statements must satisfy in order to
be present in a control-plane datastore.  For instance, maybe only
config true nodes are present, or config false nodes that also have a
specific YANG extension (e.g., ephemeral true).

** Define how control-plane data is actualized.

The diagram in ^datastore-model^ depicts control-plane datastores
feeding into the <applied> and <operational-state> datastores.  How
this interaction occurs must be defined by the control-plane
datastore.  In some cases, it may occur implicitly, as soon as the
data is put into the control-plane datastore while, in other cases, an
explicit action may be required to trigger the application of the
control-plane datastore's data.

** Define which protocols can be used.

By default, it is assumed that both the NETCONF and RESTCONF
protocol can be used to interact with a control-plane datastore.
However, it may be that only a specific protocol can be used
(e.g., forces) or that a subset of all protocol operations or
capabilities are available (e.g., no locking, no xpath-based
filtering).

** Define a module

Each control-plane datastore definition MUST define a YANG module
that can be used to 1) identify servers that support the datastore,
and 2) define an 'origin' identity that can be used for data that
originates from the datastore.

IETF modules MUST be called "ietf-ds-<datastore-name>".

All modules MUST import "ietf-yang-architecture" in order to obtain
the base origin identity used (e.g., 'dynamic' for control-plane
datastores).


* Data Model @module@

!! include-figure ietf-yang-architecture.yang extract-to="ietf-yang-architecture@2016-10-13.yang"

* IANA Considerations

TBD

- register module "ietf-yang-archiecture"
- register ns "urn:ietf:params:xml:ns:yang:ietf-yang-architecture"
- create a new registry for datastore names? (^cp-ds-guidelines^)

* Security Considerations

This document discusses a conceptual model of datastores for network
management using NETCONF/RESTCONF and YANG.  It has no security impact
on the Internet.

* Acknowledgments

This document grew out of many discussions that took place since 2010.
Several Internet-Drafts (^I-D.bjorklund-netmod-operational^,
^I-D.wilton-netmod-opstate-yang^, ^I-D.ietf-netmod-opstate-reqs^,
^I-D.kwatsen-netmod-opstate^, ^I-D.openconfig-netmod-opstate^) and
^RFC6244^ touched on some of the problems of the original datastore
model.  The following people were authors to these Internet-Drafts or
otherwise actively involved in the discussions that led to this
document:

- Lou Berger, LabN Consulting, L.L.C., <lberger@labn.net>
- Andy Bierman, YumaWorks, <andy@yumaworks.com>
- Marcus Hines, Google, <hines@google.com>
- Christian Hopps, Deutsche Telekom, <chopps@chopps.org>
- Acee Lindem, Cisco Systems, <acee@cisco.com>
- Ladislav Lhotka, CZ.NIC, <lhotka@nic.cz>
- Thomas Nadeau, Brocade Networks, <tnadeau@lucidvision.com>
- Anees Shaikh, Google, <aashaikh@google.com>
- Rob Shakir, Google, <robjs@google.com>

Juergen Schoenwaelder was partly funded by Flamingo, a Network of
Excellence project (ICT-318488) supported by the European Commission
under its Seventh Framework Programme.

*! start-appendix

* Example Data

In this example, the following fictional module is used:

!! include-figure example-system.yang

The operator has configured the host name and two interfaces, so the
contents of <intended> is:

!! include-figure ex-intended.load

The system has detected that the hardware for one of the configured
interfaces ("eth1") is not yet present, so the configuration for that
interface is not applied.  Further, the system has received a host name
and an additional IP address for "eth0" over DHCP.  This is reflected
in <applied>:

!! include-figure ex-applied.load

In <operational-state>, all data from <applied> is present, in
addition to a default value, a loopback interface automatically added
by the system, and the result of the "speed" auto-negotiation:

!! include-figure ex-oper.load

* Open Issues @issues@

+ Do we need another DS <active> inbetween <running> and <intended>?
  This DS would allow a client to see all active nodes, including
  unexpanded templates.
+ How do we handle semantical constraints in <operational-state>?  Are
  they just ignored?  Do we need a new YANG statement to define if a
  "must" constraints applies to the <operational-state>?
+ Should it be possible to ask for <applied> in RESTCONF?
+ Better name for "static configuration"?
+ Better name for "intended"?

* Implications on NETCONF

- A mechanism is needed to announce support for <intended>,
  <applied>, and <operational-state>.
- Support for <intended>, <applied>, and <operational-state>
  should be optional to implement.
- For systems supporting <intended> or <applied> configuration
  datastores, the <get-config/> operation may be used to retrieve data
  stored in these new datastores.
- A new operation should be added to retrieve the operational state
  data store (e.g., <get-state/>).  An alternative is to define a new
  operation to retrieve data from any datastore (e.g., <get-data> with
  the name of the datastore as a parameter).  In principle
  <get-config/> could work but it would be a confusing name.
- The <get/> operation will be deprecated since it returns data from
  two datastores that may overlap in the datastore model.

** Migration Path

A common approach in current data models is to have two separate trees
"/foo" and "/foo-state", where the former contains config true nodes,
and the latter config false nodes.  A data model that is designed for
the architectural framework presented in this document will
have a single tree "/foo" with a combination of config true and config
false nodes.

A server that implements the <operational-state> datastore can
implement a module of the old design.  In this case, some instances
are probably reported both in the "/foo" tree and in the "/foo-state"
tree.

A server that does not implement the <operational-state> datastore can
implement a module of the new design, but with limited functionality.
Specifically, it may not be possible to retrieve all operationally
used instances (e.g., dynamically configured or system-controlled).
The same limitation applies to a client that does not implement the
<operational-state> datastore, but talks to a server that implements
it.

* Implications on RESTCONF

This section describes the authors' thoughts on how RESTCONF could be
updated to support the datastore architecture described in this draft.
It has been incorporated as an appendix of this document to facilate
easier review, but the expectation is that this work will be owned and
standized via the NETCONF working group.

** Introduction

RESTCONF ^RFC8040^ defines a protocol based on HTTP for configuring
data defined in YANG version 1 or 1.1, using a conceptual datastore
that is compatible with a server that implements NETCONF 1.1 compliant
datastores.

The combined conceptual datastore defined in RESTCONF is incompatible
with the new datastore architecture defined in this document. There
are two possible ways that RESTCONF could be extended to support the
new architecture: Either as new optional capabilities extending the
existing RESTCONF RFC, or as an new version of RESTCONF.

Many of the required additions are common to both approaches, and are
described below.  A following section then describes the benefits of
defining a new RESTCONF version, and the additional changes that would
entail.

** Overview of additions to RESTCONF

- A new path {+restconf}/datastore/<datastore-name>/data/
  to provide a YANG datatree for each datastore that is exposed via
  RESTCONF.

- Implementations can choose which datastores they expose, but MUST at
  least expose both the <running> and <operational> datastores.  They
  MAY expose additional datastores, such as <intended> or <applied>.
  TODO - Document how supported datastores are advertised.

- The same HTTP Methods supported on {+restconf}/data/ are also
  supported on {+restconf}/datastore/<datastore-name>/data/ but
  suitably constrained depending on whether the datastore can be
  written to by the client, or is read-only.

- The same query parameters supported on {+restconf}/data/ are also
  support on {+restconf}/datastore/<datastore-name>/data/ except for
  the following query parameters:

 - 'content' - is not supported on any of the new datastore paths.

 - 'meta-data' - is a new optional query parameter that only applies
   to the operational state datastore, and filters the returned data
   based on the meta-data annotation.

 - 'with-meta-data' - is a new optional query parameter that applies
   to the operational state datastore, indicating that the origin
   meta-data should be included in the reply.

 - 'with-defaults' is supported on all configuration datastores, but
   is not supported on the operational state datastore path, because
   it has different default handling semantics.

- The handling of defaults (include the with-defaults query parameter)
  for the new configuration datastores is the same as the existing
  conceptual datastore, but doesn't apply for the operational state
  datastore that defines new semantics.

*** HTTP Methods

All configuration datastores support all HTTP Methods.

The <operational-state> datastore only supports the following HTTP methods:
OPTIONS, HEAD, GET, and POST to invoke an RFC operation.

*** Query parameters

The 'content' query parameter is not supported by RESTCONF v2 because
its functionality has been obsoletely by the revised datastores
architecture.

The 'meta-data' query parameter allows the returned data to be
restricted by its associated origin meta-data. It takes a single
parameter containing a simple logic filter expression (i.e. and, or,
not, bracketing) of origin meta-data tags.  The response is restricted
to those nodes with origin meta-data that match, or is derived from
origin meta-data that matches, the filter.  Note that regardless of
these origin meta-data, ancestor nodes (if any) and list key leafs (if
any) are also returned.

The 'with-meta-data' query parameter can only be used on requests to
<operational>, and ensures that origin meta-data annotations are
included in the response, encoded according to YANG Metadata
^RFC7952^.  If this query parameter is not specified, then origin
metadata information is not included in the response.

A new capability is defined to indicate whether a device supports
filtering on, or annotating responses with, the origin meta data.
DISCUSS: Presume that one capability is sufficient because if a device
can filter on the origin metadata then it should also be able to
annotate.

*** Operational State Datastore Defaults Handling

DISCUSS: Should the description in 4.3 also be updated to explain the
"default" handling semantics in the operational state datastore.

The normal semantics for the <operational-state> datastore are that
all values that match the default specified in the schema are included
in response to requests on the operational state datastore. This is
equivalent to the 'report-all' mode of the with-defaults handling.

The 'meta-data' query parameter can be used to exclude nodes with a
origin meta-data matching 'data-model', that would exclude (only
config true?) nodes that match the default value specified in the
schema.

If the server cannot return a value for any reason (e.g. the server
cannot determine the value, or the value that would be returned is
outside the allowed leaf value range) then the server can choose to
not return any value for a particular leaf, which MUST be interpreted
by the client as the value of that leaf not being known, rather than
implicitly having the default value.

Issue: RESTCONF v1 changes the default handling semantics if a GET
request is made against a path that hasn't been explicitly configured.
This doesn't seem to make so much sense in the revised datastores
architecture.


** Overview of RESTCONF version 2

This section describes RESTCONF version 2, by explaining the
differences to RESTCONF version 1.  Where not explicitly specified,
the behaviour of RESTCONF version 2 is the same as for RESTCONF
version 1 ^RFC8040^.

*** Benefits of defining a new RESTCONF version

Defining a new version of RESTCONF (as opposed to extending RESTCONF
version 1) has several benefits:

- It exposes datastores, and models designed for the revised datastore
  architecture, in a clean and consistent way.

- It allows the parts of RESTCONF that don't work well with the
  revised datastore architecture to be omitted from RESTCONF v2.

- It makes it easier for clients and servers to know what reasonable
  common baseline functionality to expect, rather than a collection of
  capabilities that may not be implemented in a consistent fashion.

- It can gracefully coexist with RESTCONF v1.  A server could implement both
  versions.  Existing YANG models exposing split config/state trees
  could be exposed via RESTCONF v1, whereas combined config/state YANG models
  could be exposed via RESTCONF v2, providing a viable server upgrade path.

*** Proposed changes for RESTCONF v2

The differences between RESTCONF version 2 (RESTCONF v2) and RESTCONF
version 1 (RESTCONF v1) ^RFC8040^ can be summarized as:

- RESTCONF v2 defines a new root resource (referred to as
{+restconf2}, and a separate link relation in the
/.well-known/host-meta resource.

- RESTCONF v2 removes support for the {+restconf}/data path supported
  in RESTCONF v1.

- RESTCONF v2 removes support for the content query parameter, since
  it no longer useful in the revised datastore architecture.

- RESTCONF v2 can publish a separate version of YANG library from a
  RESTCONF v1 implementation running on the same device, allowing
  different versions of RESTCONF to support a different set of YANG
  modules.

*** Possible Migration Path using RESTCONF v2

A common approach in current data models is to have two separate trees
"/foo" and "/foo-state", where the former contains config true nodes,
and the latter config false nodes.  A data model that is designed for
the revised architectural framework presented in this document will
have a single tree "/foo" with a combination of config true and config
false nodes.

If for backwards compatbility reasons, a server intends to support both
split config/state trees, and the combined config/state trees proposed
in this architecture, then this can be achieved by having the device
support both RESTCONF v1 and RESTCONF v2 at the same time:

 - The RESTCONF v1 implementation could support YANG module revisions
   with split config/state trees.

 - The RESTCONF v2 implementation could support different YANG
   modules, or YANG module revisions, with combined config/state
   trees.

Clients can then decide on which type of models to use by choosing
whether to use the RESTCONF v1 root resource or the RESTCONF v2 root
resource.


* Implications on YANG

- Some clarifications may be needed if this datastore model is
  adopted.  YANG currently describes validation in terms of the
  <running> configuration datastore while it really happens on the
  <intended> configuration datastore.

- [DISCUSS: We need to discuss somewhere how remote procedure calls
  and notifications/actions tie into datastores RFC 7950 shows as an
  example a ping action tied to an interface. Does this refer to an
  interface defined in a configuration datastore? Or an interface
  defined in the operational state datastore? Or the applied
  configuration datastore? Similarly, RFC 7950 shows an example of a
  link-failure notification; this likely applies implicitly to the
  operational state datastore. The netconf-config-change notification
  does explicitly identify a datastore. I think we generally need to
  have remote procedure calls and notifications be explicit about which
  datastores they apply to and perhaps change the default xpath context
  from running plus state to the operational state datastore.]

* Implications on YANG library @yang-lib-impl@

NOTE: This appendix provides initial text regarding how the YANG
module "ietf-yang-library" ^RFC7895^ might be updated.  If accepted by
the WG, the intention is that a separate rfc7895bis document is
created.

[TBD (mbj)]

* Implications on Data Models

- Since the NETCONF <get/> operation returns the content of the
  <running> configuration datastore and the operational state together
  in one tree, data models were often forced to branch at the
  top-level into a config true branch and a structurally similar
  config false branch that replicated some of the config true nodes
  and added state nodes.  With the datastore model described here this
  is not needed anymore since the different datastores handle the
  different lifetimes of data objects.  Introducing this model
  together with the deprecation of the <get/> operation makes it
  possible to write simpler models.
- There may be some differences in the value set of some nodes that
  are used for both configuration and state.  At this point of time,
  these are considered to be rare cases that can be dealt with using
  different nodes for the configured and state values.
- It is important to design data models with clear semantics
  that work equally well for instantiation in a configuration
  datastore and instantiation in the <operational-state> datastore.

* Data Model Design Guidelines

** Auto-configured or Auto-negotiated Values

Sometimes configuration leafs support special values that instruct the
system to automatically configure a value.  An example is an MTU that
is configured to 'auto' to let the system determine a suitable MTU
value.  Another example is Ethernet auto-negotiation of link speed.  In
such a situation, it is recommended to model this as two separate
leafs, one config true leaf for the input to the auto-negotiation
process, and one config false leaf for the output from the process.


* Ephemeral Control-Plane Datastore 

  The section defines an example control-plane datastore using
  the guidelines in ^cp-ds-guidelines^.  While this example is
  very terse, it is expected that it would be a standalone RFC
  when fully expanded as an RFC.

  This example defines a control-plane datastore called :ephemeral,
  which is loosely modelled after the work done in the I2RS working
  group.

  1. Name            : ephemeral  (register with IANA)
  2. YANG modules    : all (default)
  3. YANG statements : config false + ephemeral true
  4. How applied     : automatic
  5. Protocols       : NC/RC (default)
  6. YANG Module     : (see below)

    module ietf-ds-ephemeral {
      namespace "urn:ietf:params:xml:ns:yang:ietf-ds-ephemeral";
      prefix e;
      import ietf-yang-architecture {
        prefix arch;
      }
      identity ephemeral {
        base arch:dynamic;
        description
          "Denotes data from the ephemeral control-plane datastore.";
      }
    }

  [DISCUSS: this needs to be a valid module example now, right?]



{{document:
    name ;
    ipr trust200902;
    category std;
    references back.xml;
    title "YANG Datastore Architecture";
    contributor "editor:Martin Bjorklund:Tail-f Systems:mbj@tail-f.com";
    contributor "author:Juergen Schoenwaelder:Jacobs University:j.schoenwaelder@jacobs-university.de";
    contributor "author:Phil Shafer:Juniper:phil@juniper.net";
    contributor "author:Kent Watsen:Juniper:kwatsen@juniper.net";
    contributor "author:Rob Wilton:Cisco:rwilton@cisco.com";
}}
